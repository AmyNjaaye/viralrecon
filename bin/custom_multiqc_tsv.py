#!/usr/bin/env python

import os
import sys
import errno
import argparse
import yaml
from collections import OrderedDict

def parse_args(args=None):
    Description = 'Create custom content spreadsheet for pertinent MultiQC metrics generated by the nf-core/viralrecon pipeline.'
    Epilog = "Example usage: python custom_multiqc_tsv.py"
    parser = argparse.ArgumentParser(description=Description, epilog=Epilog)
    parser.add_argument('-md', '--multiqc_data_dir', type=str, dest="MULTIQC_DATA_DIR", default='./multiqc_data/', help="Full path to directory containing YAML files for each module, as generated by MultiQC. (default: './multiqc_data/').")
    parser.add_argument('-of', '--out_file', type=str, dest="OUT_FILE", default='./viralrecon_summary_stats.txt', help="Full path to output file (default: './viralrecon_summary_stats.txt').")
    return parser.parse_args(args)


def make_dir(path):
    if not len(path) == 0:
        try:
            os.makedirs(path)
        except OSError as exception:
            if exception.errno != errno.EEXIST:
                raise


# Find key in dictionary created from YAML file recursively
# From https://stackoverflow.com/a/37626981
def find_tag(d, tag):
    if tag in d:
        yield d[tag]
    for k,v in d.items():
        if isinstance(v, dict):
            for i in find_tag(v, tag):
                yield i

# Load YAML as an ordered dict
# From https://stackoverflow.com/a/21912744
def yaml_ordered_load(stream):
    class OrderedLoader(yaml.SafeLoader):
        pass
    def construct_mapping(loader, node):
        loader.flatten_mapping(node)
        return OrderedDict(loader.construct_pairs(node))
    OrderedLoader.add_constructor(
        yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG,
        construct_mapping)
    return yaml.load(stream, OrderedLoader)


def yaml_fields_to_dict(YAMLFile,AppendDict={},FieldMappingDict={}):
    with open(YAMLFile) as f:
        yaml_dict = yaml_ordered_load(f)
        for k in yaml_dict.keys():
            if k not in AppendDict:
                AppendDict[k] = OrderedDict()
            if FieldMappingDict != {}:
                for i,j in FieldMappingDict.items():
                    val = list(find_tag(yaml_dict[k], j[0]))[0]
                    if len(j) == 2:
                        val = list(find_tag(val, j[1]))[0]
                    if i not in AppendDict[k]:
                        AppendDict[k][i] = val
                    else:
                        print('WARNING: {} key already exists in dictionary so will be overwritten. YAML file {}.'.format(i,YAMLFile))
            else:
                AppendDict[k] = yaml_dict[k]
    return AppendDict


def main(args=None):
    args = parse_args(args)

    ## PARSE MULTIQC YAML AND FETCH CUSTOM FIELDS
    col_dict = {}
    FileSearchList = [(args.MULTIQC_DATA_DIR + 'multiqc_fastp_fastp.yaml', OrderedDict([('Total input reads', ['before_filtering','total_reads']), ('Total reads after fastp trimming', ['after_filtering','total_reads'])])),
                      (args.MULTIQC_DATA_DIR + 'multiqc_samtools_flagstat_samtools_bowtie2.yaml', OrderedDict([('% reads mapped to virus', ['mapped_passed_pct'])])),
                      (args.MULTIQC_DATA_DIR + 'multiqc_samtools_flagstat_samtools_ivar.yaml', OrderedDict([('Total reads after iVar trimming', ['flagstat_total'])])),
                      (args.MULTIQC_DATA_DIR + 'multiqc_samtools_flagstat_samtools_markduplicates.yaml', OrderedDict([('Total reads after MarkDuplicates', ['flagstat_total']), ('Duplicate reads', ['duplicates_passed'])]))]
    for yamlFile,mappingDict in FileSearchList:
        if os.path.exists(yamlFile):
            col_dict = yaml_fields_to_dict(YAMLFile=yamlFile,AppendDict=col_dict,FieldMappingDict=mappingDict)

    ## WRITE TO FILE
    if col_dict != {}:
        make_dir(os.path.dirname(args.OUT_FILE))
        fout = open(args.OUT_FILE,'w')
        header = ['Sample'] + list(col_dict[list(col_dict.keys())[0]].keys())
        fout.write('{}\n'.format('\t'.join(header)))
        for k in sorted(col_dict.keys()):
            fout.write('{}\t{}\n'.format(k,'\t'.join(map(str,col_dict[k].values()))))
        fout.close()


if __name__ == '__main__':
    sys.exit(main())


### VARIANT CALLING FILES

# multiqc_ivar_primers_ivar_trim.yaml
# multiqc_ivar_summary_ivar_trim.yaml

# multiqc_picard_AlignmentSummaryMetrics_picard_metrics.yaml
# multiqc_picard_baseContent_picard_metrics.yaml
# multiqc_picard_dups_picard_metrics.yaml
# multiqc_picard_insertSize_picard_metrics.yaml
# multiqc_picard_quality_by_cycle_picard_metrics.yaml
# multiqc_picard_quality_score_distribution_picard_metrics.yaml
# multiqc_picard_wgsmetrics_picard_metrics.yaml

# multiqc_varscan2_summary_varscan2.yaml

# multiqc_bcftools_stats_bcftools_varscan2.yaml
# multiqc_bcftools_stats_bcftools_ivar.yaml
# multiqc_bcftools_stats_bcftools_bcftools.yaml

# multiqc_quast_quast_ivar.yaml
# multiqc_quast_quast_varscan2.yaml

# multiqc_snpeff_snpeff_varscan2.yaml
# multiqc_snpeff_snpeff_ivar.yaml
# multiqc_snpeff_snpeff_bcftools.yaml

### ASSEMBLY FILES

# multiqc_cutadapt_cutadapt.yaml
# multiqc_fastqc_fastqc_cutadapt.yaml

# multiqc_bcftools_stats_bcftools_metaspades.yaml
# multiqc_bcftools_stats_bcftools_minia.yaml
# multiqc_bcftools_stats_bcftools_spades.yaml
# multiqc_bcftools_stats_bcftools_unicycler.yaml

# multiqc_quast_quast_metaspades.yaml
# multiqc_quast_quast_minia.yaml
# multiqc_quast_quast_spades.yaml
# multiqc_quast_quast_unicycler.yaml

# multiqc_snpeff_snpeff_metaspades.yaml
# multiqc_snpeff_snpeff_minia.yaml
# multiqc_snpeff_snpeff_spades.yaml
# multiqc_snpeff_snpeff_unicycler.yaml
