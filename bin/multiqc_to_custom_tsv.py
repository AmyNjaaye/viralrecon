#!/usr/bin/env python

import os
import sys
import errno
import argparse
import yaml
from collections import OrderedDict


def parse_args(args=None):
    Description = 'Create custom spreadsheet for pertinent MultiQC metrics generated by the nf-core/viralrecon pipeline.'
    Epilog = "Example usage: python multiqc_to_custom_tsv.py"
    parser = argparse.ArgumentParser(description=Description, epilog=Epilog)
    parser.add_argument('-md', '--multiqc_data_dir', type=str, dest="MULTIQC_DATA_DIR", default='./multiqc_data/', help="Full path to directory containing YAML files for each module, as generated by MultiQC. (default: './multiqc_data/').")
    parser.add_argument('-of', '--out_file', type=str, dest="OUT_FILE", default='./viralrecon_summary_stats.txt', help="Full path to output file (default: './viralrecon_summary_stats.txt').")
    return parser.parse_args(args)


def make_dir(path):
    if not len(path) == 0:
        try:
            os.makedirs(path)
        except OSError as exception:
            if exception.errno != errno.EEXIST:
                raise


# Find key in dictionary created from YAML file recursively
# From https://stackoverflow.com/a/37626981
def find_tag(d, tag):
    if tag in d:
        yield d[tag]
    for k,v in d.items():
        if isinstance(v, dict):
            for i in find_tag(v, tag):
                yield i


# Load YAML as an ordered dict
# From https://stackoverflow.com/a/21912744
def yaml_ordered_load(stream):
    class OrderedLoader(yaml.SafeLoader):
        pass
    def construct_mapping(loader, node):
        loader.flatten_mapping(node)
        return OrderedDict(loader.construct_pairs(node))
    OrderedLoader.add_constructor(
        yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG,
        construct_mapping)
    return yaml.load(stream, OrderedLoader)


def yaml_fields_to_dict(YAMLFile,AppendDict={},FieldMappingDict={}):
    with open(YAMLFile) as f:
        yaml_dict = yaml_ordered_load(f)
        for k in yaml_dict.keys():
            key = k
            if YAMLFile.find('multiqc_picard_insertSize') != -1:
                key = k[:-3]
            if key not in AppendDict:
                AppendDict[key] = OrderedDict()
            if FieldMappingDict != {}:
                for i,j in FieldMappingDict.items():
                    val = list(find_tag(yaml_dict[k], j[0]))[0]
                    if len(j) == 2:
                        val = list(find_tag(val, j[1]))[0]
                    if i not in AppendDict[key]:
                        AppendDict[key][i] = val
                    else:
                        print('WARNING: {} key already exists in dictionary so will be overwritten. YAML file {}.'.format(i,YAMLFile))
            else:
                AppendDict[k] = yaml_dict[k]
    return AppendDict


def main(args=None):
    args = parse_args(args)

    ## PARSE MULTIQC YAML AND FETCH CUSTOM FIELDS
    FileSearchList = [('multiqc_fastp_fastp.yaml', OrderedDict([('Total input reads', ['before_filtering','total_reads']), ('Total reads after fastp trimming', ['after_filtering','total_reads'])])),
                      ('multiqc_samtools_flagstat_samtools_bowtie2.yaml', OrderedDict([('% reads mapped to virus', ['mapped_passed_pct'])])),
                      ('multiqc_ivar_summary_ivar_trim.yaml', OrderedDict([('Total reads trimmed by iVar', ['trimmed_reads'])])),
                      ('multiqc_samtools_flagstat_samtools_ivar.yaml', OrderedDict([('Total reads after iVar trimming', ['flagstat_total'])])),
                      ('multiqc_samtools_flagstat_samtools_markduplicates.yaml', OrderedDict([('Total reads after MarkDuplicates', ['flagstat_total']), ('Duplicate reads', ['duplicates_passed'])])),
                      ('multiqc_picard_insertSize_picard_metrics.yaml', OrderedDict([('Insert size mean', ['MEAN_INSERT_SIZE']), ('Insert size std dev', ['STANDARD_DEVIATION'])])),
                      ('multiqc_picard_wgsmetrics_picard_metrics.yaml', OrderedDict([('Coverage mean', ['MEAN_COVERAGE']), ('Coverage std dev', ['SD_COVERAGE']), ('% Coverage > 10x', ['PCT_10X'])])),
                      # ('multiqc_varscan2_summary_varscan2.yaml', OrderedDict([('Total reads after iVar trimming', ['flagstat_total'])])),
                      # ('multiqc_bcftools_stats_bcftools_varscan2.yaml', OrderedDict([('Total reads after iVar trimming', ['flagstat_total'])])),
                      # ('multiqc_snpeff_snpeff_varscan2.yaml', OrderedDict([('Total reads after iVar trimming', ['flagstat_total'])])),
                      # ('multiqc_quast_quast_varscan2.yaml', OrderedDict([('Total reads after iVar trimming', ['flagstat_total'])])),
                      # ('multiqc_bcftools_stats_bcftools_ivar.yaml', OrderedDict([('Total reads after iVar trimming', ['flagstat_total'])])),
                      # ('multiqc_snpeff_snpeff_ivar.yaml', OrderedDict([('Total reads after iVar trimming', ['flagstat_total'])])),
                      # ('multiqc_quast_quast_ivar.yaml', OrderedDict([('Total reads after iVar trimming', ['flagstat_total'])])),
                      # ('multiqc_bcftools_stats_bcftools_bcftools.yaml', OrderedDict([('Total reads after iVar trimming', ['flagstat_total'])])),
                      # ('multiqc_snpeff_snpeff_bcftools.yaml', OrderedDict([('Total reads after iVar trimming', ['flagstat_total'])])),
                      # ('multiqc_cutadapt_cutadapt.yaml', OrderedDict([('Total reads after iVar trimming', ['flagstat_total'])])),
                      # ('multiqc_fastqc_fastqc_cutadapt.yaml', OrderedDict([('Total reads after iVar trimming', ['flagstat_total'])])),
                      # ('multiqc_bcftools_stats_bcftools_spades.yaml', OrderedDict([('Total reads after iVar trimming', ['flagstat_total'])])),
                      # ('multiqc_quast_quast_spades.yaml', OrderedDict([('Total reads after iVar trimming', ['flagstat_total'])])),
                      # ('multiqc_snpeff_snpeff_spades.yaml', OrderedDict([('Total reads after iVar trimming', ['flagstat_total'])])),
                      # ('multiqc_bcftools_stats_bcftools_metaspades.yaml', OrderedDict([('Total reads after iVar trimming', ['flagstat_total'])])),
                      # ('multiqc_quast_quast_metaspades.yaml', OrderedDict([('Total reads after iVar trimming', ['flagstat_total'])])),
                      # ('multiqc_snpeff_snpeff_metaspades.yaml', OrderedDict([('Total reads after iVar trimming', ['flagstat_total'])])),
                      # ('multiqc_bcftools_stats_bcftools_unicycler.yaml', OrderedDict([('Total reads after iVar trimming', ['flagstat_total'])])),
                      # ('multiqc_quast_quast_unicycler.yaml', OrderedDict([('Total reads after iVar trimming', ['flagstat_total'])])),
                      # ('multiqc_snpeff_snpeff_unicycler.yaml', OrderedDict([('Total reads after iVar trimming', ['flagstat_total'])])),
                      # ('multiqc_bcftools_stats_bcftools_minia.yaml', OrderedDict([('Total reads after iVar trimming', ['flagstat_total'])])),
                      # ('multiqc_quast_quast_minia.yaml', OrderedDict([('Total reads after iVar trimming', ['flagstat_total'])])),
                      # ('multiqc_snpeff_snpeff_minia.yaml', OrderedDict([('Total reads after iVar trimming', ['flagstat_total'])]))
                      ]

    col_dict = {}
    fieldList = []
    for yamlFile,mappingDict in FileSearchList:
        yamlFile = os.path.join(args.MULTIQC_DATA_DIR,yamlFile)
        if os.path.exists(yamlFile):
            col_dict = yaml_fields_to_dict(YAMLFile=yamlFile,AppendDict=col_dict,FieldMappingDict=mappingDict)
            fieldList += mappingDict.keys()

    ## WRITE TO FILE
    if col_dict != {}:
        make_dir(os.path.dirname(args.OUT_FILE))
        fout = open(args.OUT_FILE,'w')
        header = ['Sample'] + fieldList
        fout.write('{}\n'.format('\t'.join(header)))
        for k in sorted(col_dict.keys()):
            rowList = [k]
            for field in fieldList:
                if field in col_dict[k]:
                    rowList.append(col_dict[k][field])
                else:
                    rowList.append('NA')
            fout.write('{}\n'.format('\t'.join(map(str,rowList))))
        fout.close()


if __name__ == '__main__':
    sys.exit(main())
